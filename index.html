<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <!--  Import Halfmoon -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/halfmoon/css/halfmoon-variables.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/halfmoon/css/halfmoon.min.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/halfmoon/js/halfmoon.min.js"></script>
    <title>ALBW Randomizer</title>
    <style>
      html,
      body {
        font-family: "Roboto", sans-serif;
        background: #333;
        color: #f5f5f5;
      }
    </style>
    <script>
      window.onload = () => {
        if (
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
        ) {
          halfmoon.toggleDarkMode();
        }
      };
    </script>
  </head>
  <body>
    <script type="module">
      const onlyUnique = (value, index, self) => {
        return self.indexOf(value) === index;
      };

      const internalNameToDisplayName = (internalName) => {
        if (!internalName.includes("Key") && !internalName.includes("Bottle")) {
          if (internalName.includes("02")) {
            return internalName
              .replace(/([A-Z])/g, " $1")
              .replace("02", " (Upgrade)")
              .replace(/\d+/, "")
              .trim();
          }
        }

        return internalName
          .replace(/\d+/, "")
          .replace(/([A-Z])/g, " $1")
          .trim();
      };

      const displayNameToIconPath = (itemName) => {
        const progressiveItems = ["Glove", "Sword", "Bracelet", "Mail"];
        const conversion = (itemName) => {
          if (itemName.includes("Ore")) {
            return `Master Ore`;
          }
          if (itemName.includes("Compass")) {
            return `Compass`;
          }
          const progressiveItem = progressiveItems.find((pItem) =>
            itemName.includes(pItem)
          );
          if (progressiveItem) {
            return `Progressive ${progressiveItem}`;
          }
          if (
            itemName.includes("Key") &&
            (itemName.includes("Big") || itemName.includes("Sanctuary"))
          ) {
            return `Big Key`;
          }
          if (itemName.includes("Key") && itemName.includes("Small")) {
            return `Small Key`;
          }
          return itemName;
        };

        return `./items/${conversion(itemName)}.png`;
      };

      import init, { Cartridge } from "./albw_wasm.js";
      await init();

      class GameInfo {
        constructor(settings, seed) {
          this.seed = seed;
          this.settings = settings;
          this.cartridge = new Cartridge(settings, seed);
          this.loadProgress();
        }

        resetProgress() {
          if (
            !confirm("Are you sure you want to reset ALL items and checks?")
          ) {
            return;
          }
          localStorage.removeItem("collectedItemNames." + this.seed);
          localStorage.removeItem("visitedCheckNames." + this.seed);
          refreshItems();
          refreshChecks();
        }

        saveItemProgress(collectedItemNames) {
          // store collectedItemNames in localStorage
          localStorage.setItem(
            "collectedItemNames." + this.seed,
            JSON.stringify(collectedItemNames)
          );
        }

        // store visitedChecks in local storage
        saveCheckProgress(visitedCheckNames) {
          localStorage.setItem(
            "visitedCheckNames." + this.seed,
            JSON.stringify(visitedCheckNames)
          );
        }

        loadProgress() {
          return {
            collectedItemNames:
              JSON.parse(
                localStorage.getItem("collectedItemNames." + this.seed)
              ) || [],
            visitedCheckNames:
              JSON.parse(
                localStorage.getItem("visitedCheckNames." + this.seed)
              ) || [],
          };
        }

        async getListOfUsefulProgressionItems() {
          const removeRupees = (itemName) => !itemName.includes("Rupee");
          const displayNameToIconAndRequest = ([internalName, displayName]) =>
            new Promise(async (resolve, reject) => {
              const iconPath = displayNameToIconPath(
                displayName.replace(/ \(.*/, "")
              );
              let requestSuccess = false;
              try {
                const response = await fetch(iconPath);
                if (response.ok) {
                  requestSuccess = true;
                }
              } catch (e) {
                console.error(e);
              }
              resolve({ internalName, displayName, iconPath, requestSuccess });
            });

          const getUniqueWithoutNumber = (value, index, self) =>
          {
            if (value.displayName.includes("Ravio") || value.displayName.includes("Glove") )
            {
              return () => true;
            }
            return onlyUnique(
              value.internalName.replace(/\d+/, ""),
              index,
              self.map((itemData) => itemData.internalName.replace(/\d+/, ""))
            );
          }

          return (
            await Promise.all(
              this.cartridge
                .get_progression_item_names()
                .filter(removeRupees)
                .map((internalName) => [
                  internalName,
                  internalNameToDisplayName(internalName),
                ])
                .map(displayNameToIconAndRequest)
            )
          ).filter(getUniqueWithoutNumber);
        }
      }

      window.gameInfo = new GameInfo(
        {
          logic: {
            mode: "Normal",
            assured_weapon: false,
            bell_in_shop: false,
            pouch_in_shop: false,
            boots_in_shop: false,
            minigames_excluded: true,
            swordless_mode: false,
            super_items: true,
            skip_trials: true,
            bow_of_light_in_castle: false,
            lampless: false,
          },
          options: {
            night_mode: false,
          },
          exclusions: {},
          exclude: {
            hyrule: {},
            lorule: {},
            dungeons: {},
          },
        },
        2832764187
      );

      console.log(window.gameInfo.cartridge);
      console.log(window.gameInfo.cartridge.get_trash_item_names());
      console.log(window.gameInfo.cartridge.get_progression_item_names());
      console.log(window.gameInfo.cartridge.get_available_checks([]));
      console.log(window.gameInfo.cartridge.get_available_checks(["Bow01"]));

      // @TODO: Explicitly add Ravios bracelet

      const getCurrentlyCollectedItemCards = () =>
        Array.from(
          document.querySelectorAll("#progressive-item-list .card")
        ).map((e) => {
          return {
            checked: e.querySelector("input").checked,
            internalName: e.dataset.internalName,
          };
        });

      const refreshItems = async () => {
        const createElement = ({ internalName, displayName, iconPath }) => {
          // create halfmoon css card with left-aligned and vertically centered image and title on same line
          const card = document.createElement("div");
          card.classList.add("card", "d-flex", "align-items-center");
          card.dataset.internalName = internalName;

          // add image to card
          const cardImage = document.createElement("img");
          cardImage.src = iconPath;
          cardImage.style.marginRight = "10px";
          card.appendChild(cardImage);
          // add text to card
          const cardText = document.createElement("p");
          cardText.classList.add("card-body");
          cardText.innerText = displayName;
          card.appendChild(cardText);

          // add hidden checkbox that gets toggled when card is clicked
          const cardCheckbox = document.createElement("input");
          cardCheckbox.type = "checkbox";
          cardCheckbox.classList.add("d-none");
          cardCheckbox.addEventListener("change", (e) => {
            if (e.target.checked) {
              card.classList.add("bg-primary");
            } else {
              card.classList.remove("bg-primary");
            }
          });
          card.appendChild(cardCheckbox);
          // add click event listener to card
          card.addEventListener("click", () => {
            // @TODO: Persist progression for current seed inside local storage
            cardCheckbox.checked = !cardCheckbox.checked;
            cardCheckbox.dispatchEvent(new Event("change"));
            const currentlyCollectedItems = getCurrentlyCollectedItemCards();
            refreshChecks(currentlyCollectedItems);
            window.gameInfo.saveItemProgress(
              currentlyCollectedItems
                .filter((a) => a.checked)
                .map((item) => item.internalName)
            );
          });

          cardCheckbox.checked = window.gameInfo
            .loadProgress()
            .collectedItemNames.includes(internalName);
          cardCheckbox.dispatchEvent(new Event("change"));
          return card;
        };

        const progressionItemData =
          await window.gameInfo.getListOfUsefulProgressionItems();
        const itemListContainer = document.querySelector(
          "#progressive-item-list"
        );
        itemListContainer.innerHTML = "";
        progressionItemData.forEach((itemData) =>
          document
            .querySelector("#progressive-item-list")
            .appendChild(createElement(itemData))
        );
      };

      const refreshChecks = () => {
        let collectedChecks = window.gameInfo.loadProgress().visitedCheckNames;
        const collectedItems = getCurrentlyCollectedItemCards();
        const collectedItemsNames = collectedItems
          .filter((item) => item.checked)
          .map((item) => item.internalName);

        const availableChecks =
          window.gameInfo.cartridge.get_available_checks(collectedItemsNames);

        const alreadyVisitedChecks =
          window.gameInfo.loadProgress().visitedCheckNames;

        const availableCheckCards = availableChecks.map((checkName) => {
          // create halfmoon css card with left-aligned and vertically centered image and title on same line
          const card = document.createElement("div");
          card.classList.add("card", "d-flex", "align-items-center");
          card.dataset.checkName = checkName;

          // add text to card
          const cardText = document.createElement("p");
          cardText.classList.add("card-body");
          cardText.innerText = checkName;
          card.appendChild(cardText);

          // add hidden checkbox that gets toggled when card is clicked
          const cardCheckbox = document.createElement("input");
          cardCheckbox.type = "checkbox";
          cardCheckbox.classList.add("d-none");
          cardCheckbox.addEventListener("change", (e) => {
            if (e.target.checked) {
              card.classList.add("bg-primary");
            } else {
              card.classList.remove("bg-primary");
            }
          });
          card.appendChild(cardCheckbox);

          cardCheckbox.checked = collectedChecks.includes(checkName);
          cardCheckbox.dispatchEvent(new Event("change"));

          // add click event listener to card
          card.addEventListener("click", () => {
            // @TODO: Persist progression for current seed inside local storage
            cardCheckbox.checked = !cardCheckbox.checked;
            cardCheckbox.dispatchEvent(new Event("change"));
            if (cardCheckbox.checked) {
              collectedChecks.push(checkName);
            } else {
              collectedChecks = collectedChecks.filter(
                (check) => check !== checkName
              );
            }

            window.gameInfo.saveCheckProgress(collectedChecks);
          });

          cardCheckbox.checked = alreadyVisitedChecks.includes(checkName);
          cardCheckbox.dispatchEvent(new Event("change"));
          return card;
        });
        const checkList = document.querySelector("#check-list");
        checkList.innerHTML = "";
        availableCheckCards.forEach((element) =>
          document.querySelector("#check-list").appendChild(element)
        );
      };

      await refreshItems();
      refreshChecks();
    </script>

    <div class="page-wrapper with-navbar">
      <nav class="navbar">
        <button class="d-none d-md-flex ml-auto btn btn-primary" onclick="window.gameInfo.resetProgress()">Reset</button>
      </nav>

      <!-- Content wrapper -->
      <div class="content-wrapper">
        <div class="lists">
          <div class="checklist-wrapper">
            <h2 class="content-title">Progressive Items</h2>
            <div class="checklist" id="progressive-item-list"></div>
          </div>
          <div class="checklist-wrapper">
            <h2 class="content-title">Checks</h2>
            <div class="checklist" id="check-list"></div>
          </div>
        </div>
        <style>
          .card
          {
            user-select: none;
            cursor: pointer;
          }

          .lists {
            /* grid taking 50% of horizontal and 100% of all screen space and individually scrollable insides */
            display: grid;
            grid-template-columns: 50% 50%;
            height: 100%;
            overflow: hidden;
          }

          .checklist-wrapper {
            overflow-y: auto;
            height: 100%;
          }

          /* vertical list of items as flexbox */
          .checklist {
            display: flex;
            flex-direction: column;
            height: 100%;
          }

          .checklist .card {
            order: 1;
          }

          .checklist .card.bg-primary {
            order: 2;
          }

          .checklist img {
            width: 32px;
            height: 32px;
          }

          .checklist p {
            margin: 0;
          }

          .checklist .card {
            margin: 0.25em;
            padding: 0.25em;
          }
        </style>
      </div>
    </div>
  </body>
</html>
